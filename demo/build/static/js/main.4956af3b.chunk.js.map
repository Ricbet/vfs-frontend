{"version":3,"sources":["component/upload-form/index.tsx","component/tree/model.ts","component/tree/util.ts","component/tree/index.tsx","component/details/index.tsx","page/index.tsx","serviceWorker.js","index.tsx"],"names":["UploadForm","prop","onUploadChange","className","layout","Item","Dragger","name","accept","beforeUpload","e","Blob","type","showUploadList","TInode","children","init","this","c","Inode","generateInode","setName","setDate","date","Date","setDosPermissions","dosPermissions","setIsDir","isDir","setParentPath","parentPath","setPath","path","setUnixPermissions","unixPermissions","TreeNode","DirectoryTree","fileIcons","require","TreeComp","props","data","vfsService","onLaunchFileDetails","useState","inodeData","setInodeData","useEffect","Array","isArray","map","cur","expandDir","d","ls","then","llist","l","setChildren","sliceData","slice","quickSort","arr","length","pre","pivotFile","splice","Math","floor","left","right","i","currentFile","push","localeCompare","concat","handleSortFileList","checkFile","f","read","content","style","overflow","height","maxWidth","minWidth","onSelect","target","exist","curTree","flat","reduce","find","renderTreeNodes","item","icon","getClassWithColor","title","key","dataRef","isLeaf","Details","ZipVFSService","Page","treeData","setTreeData","treeVfss","setTreeVfss","blobUrl","setBlobUrl","isLoad","setIsLoad","currentFileDetails","setCurrentFileDetails","acceptUplodaChange","blob","a","mount","treelist","window","acquireBlobUrl","fetch","headers","responData","status","get","finally","Content","Text","textAlign","width","display","marginTop","value","onChange","onClick","spinning","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.4956af3b.chunk.js","sourcesContent":["import React from \"react\";\nimport { Form, Upload, Icon } from \"antd\";\nimport { RcFile } from \"antd/lib/upload/interface\";\n\ninterface UploadFormProps {\n    onUploadChange: (arg: Blob) => void;\n}\n\nconst UploadForm = (prop: UploadFormProps): JSX.Element => {\n    const { onUploadChange } = prop;\n\n    const acceptUploadChange = (file: RcFile): boolean => {\n        onUploadChange(new Blob([file], { type: \"text/plain\" }));\n        return false;\n    };\n\n    return (\n        <div className=\"upload-from-main\">\n            <Form layout=\"vertical\">\n                <Form.Item>\n                    <Upload.Dragger\n                        name=\"zipFiles\"\n                        accept=\".zip,.tar\"\n                        beforeUpload={e => acceptUploadChange(e)}\n                        showUploadList={false}\n                    >\n                        <p className=\"ant-upload-drag-icon\">\n                            <Icon type=\"inbox\" />\n                        </p>\n                        <p className=\"ant-upload-text\">单击或拖动文件到此区域上传</p>\n                        <p className=\"ant-upload-hint\">仅支持 ZIP 压缩包</p>\n                    </Upload.Dragger>\n                </Form.Item>\n                {/* <Form.Item>\n                    <Button type=\"primary\" style={{ width: \"100%\" }} onClick={() => onExportZip(fileName)}>\n                        导出为新压缩包\n                    </Button>\n                </Form.Item> */}\n            </Form>\n        </div>\n    );\n};\n\nexport default UploadForm;\n","import { Inode } from \"vfs-frontend\";\n\nexport class TInode extends Inode {\n\n    public children!: TInode[]\n\n    constructor() {\n        super();\n        this.init()\n    }\n\n    public init(): void {\n        this.children = []\n    }\n\n    public setChildren(c: TInode[]): this {\n        this.children = c || []\n        return this\n    }\n\n}\n","import { TInode } from \"./model\";\n\nexport const generateInode = (e: TInode): TInode => {\n    return new TInode()\n        .setName(e.name)\n        .setDate(e.date || new Date())\n        .setDosPermissions(e.dosPermissions!)\n        .setIsDir(e.isDir)\n        .setParentPath(e.parentPath)\n        .setPath(e.path)\n        .setUnixPermissions(e.unixPermissions!);\n};\n\n// 文件排序\nexport const handleSortFileList = (data: TInode[]): TInode[] => {\n    // 比较首字母ACS编码排序\n    const sliceData = data.slice(0);\n    const sortCharCode = (pre: TInode, cur: TInode): boolean => cur.name.localeCompare(pre.name) > 0;\n    const quickSort = (arr: TInode[]): TInode[] => {\n        if (arr.length <= 1) return arr;\n        const pivotFile = arr.splice(Math.floor(arr.length / 2), 1)[0];\n        const left = [];\n        const right = [];\n        for (let i = 0; i < arr.length; i++) {\n            const currentFile = arr[i];\n            if (currentFile.isDir === true && pivotFile.isDir === false) left.push(currentFile);\n            else {\n                if (currentFile.isDir === pivotFile.isDir) {\n                    sortCharCode(currentFile, pivotFile) ? left.push(currentFile) : right.push(currentFile);\n                } else right.push(currentFile);\n            }\n        }\n        return quickSort(left).concat([pivotFile], quickSort(right));\n    };\n    const result = quickSort(sliceData);\n    return result;\n};\n\nexport const findTreeData = (source: TInode[], target: string): TInode | undefined => {\n    const flat = (arr: TInode[]): TInode[] => {\n        return arr.reduce(\n            (pre: TInode[], cur) =>\n                Array.isArray(cur.children) && cur.children.length > 0\n                    ? pre.concat(flat(cur.children))\n                    : pre.concat(cur),\n            []\n        );\n    };\n    const dimenList = flat(source);\n    return dimenList.find(e => e.path === target);\n};\n","import React, { useEffect, useState } from \"react\";\nimport { Tree } from \"antd\";\nimport { TInode } from \"./model\";\nimport { ZipVFSService } from \"vfs-frontend\";\nimport { generateInode, handleSortFileList, findTreeData } from \"./util\";\nimport \"../../file-icons-js.css\";\n\nconst { TreeNode, DirectoryTree } = Tree;\nconst fileIcons = require(\"file-icons-js\");\n\ninterface PropsTreeComp {\n    data: TInode[];\n    vfsService?: ZipVFSService;\n    onLaunchFileDetails?: (d: string) => void;\n}\n\nconst TreeComp = (props: PropsTreeComp): JSX.Element => {\n    const { data, vfsService, onLaunchFileDetails } = props;\n\n    const [inodeData, setInodeData] = useState<TInode[]>([]);\n\n    useEffect(() => {\n        if (Array.isArray(data)) {\n            setInodeData(data.map(cur => generateInode(cur)));\n        }\n    }, [data]);\n\n    const selectNode = (e: string[]): void => {\n        if (!vfsService) return;\n\n        const [path] = e;\n\n        if (vfsService.exist(path)) {\n            const curTree = findTreeData(inodeData, path);\n            if (!curTree) return;\n\n            if (curTree.isDir) {\n                expandDir(curTree);\n            } else {\n                checkFile(curTree);\n            }\n        }\n    };\n\n    const expandDir = (d: TInode) => {\n        if (!vfsService) return;\n        vfsService.ls(d.path).then(ls => {\n            const llist = ls.map(l => generateInode(l as TInode));\n            d.setChildren(handleSortFileList(llist));\n            setInodeData([...inodeData]);\n        });\n    };\n\n    const checkFile = (f: TInode) => {\n        if (!vfsService || !onLaunchFileDetails) return;\n        vfsService.read(f.path).then(content => {\n            if (typeof content === \"string\") onLaunchFileDetails(content);\n        });\n    };\n\n    const renderTreeNodes = (data: TInode[]): JSX.Element[] => {\n        return data.map(item => {\n            return (\n                <TreeNode\n                    icon={item.isDir ? null : <i className={fileIcons.getClassWithColor(item.name) || \"fa-file-o\"}></i>}\n                    title={item.name}\n                    key={item.path}\n                    dataRef={item}\n                    isLeaf={!item.isDir}\n                >\n                    {renderTreeNodes(item.children)}\n                </TreeNode>\n            );\n        });\n    };\n\n    return (\n        <div className=\"tree-comp\" style={{ overflow: \"auto\", height: \"100%\", maxWidth: \"300px\", minWidth: \"240px\" }}>\n            {inodeData.length ? (\n                <DirectoryTree onSelect={selectNode}>{renderTreeNodes(inodeData)}</DirectoryTree>\n            ) : null}\n        </div>\n    );\n};\n\nexport default TreeComp;\n","import React from \"react\";\n\nimport \"./index.scss\";\n\ninterface PropsDetails {\n    content: string;\n}\n\nconst Details = (props: PropsDetails): JSX.Element => {\n    const { content } = props;\n    return (\n        <div className=\"details-main\">\n            <div className=\"pre-content\">\n                <pre>{content}</pre>\n            </div>\n        </div>\n    );\n};\n\nexport default Details;\n","import React, { useState } from \"react\";\nimport { Layout, Typography, Input, Button, Spin } from \"antd\";\nimport UploadForm from \"../component/upload-form\";\nimport { ZipVFSService, Inode } from \"vfs-frontend\";\nimport TreeComp from \"../component/tree\";\n\nimport \"./index.scss\";\nimport { TInode } from \"../component/tree/model\";\nimport Details from \"../component/details\";\n\nconst vfsService = new ZipVFSService();\n\nconst Page = () => {\n    const [treeData, setTreeData] = useState<Inode[]>([]);\n    const [treeVfss, setTreeVfss] = useState<ZipVFSService>();\n    const [blobUrl, setBlobUrl] = useState<string>(\"\");\n    const [isLoad, setIsLoad] = useState<boolean>(false);\n    const [currentFileDetails, setCurrentFileDetails] = useState<string>(\"\");\n\n    const acceptUplodaChange = async (blob: Blob) => {\n        vfsService.mount(blob).then(async () => {\n            const treelist = await vfsService.ls(\"/\");\n            setTreeData(treelist || []);\n            setTreeVfss(vfsService);\n            (window as any).vfsService = vfsService\n        });\n    };\n\n    const onCurrentFileContent = (content: string) => {\n        setCurrentFileDetails(content);\n    };\n\n    const acquireBlobUrl = () => {\n        setIsLoad(true)\n        fetch(blobUrl, {\n            headers: { \"content-type\": \"application/zip\" },\n        }).then(async responData => {\n            if (\n                responData &&\n                responData.status === 200 &&\n                responData.headers.get(\"content-type\") === \"application/zip\"\n            ) {\n                const data = await responData.blob();\n                acceptUplodaChange(data);\n            }\n        }).finally(() => {\n            setIsLoad(false)\n        })\n    };\n\n    const renderFeatchUrlForm = (): JSX.Element => {\n        return (\n            <div className=\"feact-url\">\n                <Typography.Text>返回 Blob 数据格式的接口</Typography.Text>\n                <Input style={{ marginTop: \"10px\" }} value={blobUrl} onChange={e => setBlobUrl(e.target.value)}></Input>\n                <Button type=\"primary\" style={{ width: \"100%\", marginTop: \"10px\" }} onClick={acquireBlobUrl}>\n                    确定\n                </Button>\n            </div>\n        );\n    };\n\n    return (\n        <div className=\"page\">\n            <Layout style={{ height: \"100vh\" }}>\n                <Layout.Content className=\"content\">\n                    <div className=\"left\">\n                        <UploadForm onUploadChange={acceptUplodaChange} />\n                        <Typography.Text style={{ textAlign: \"center\", width: \"100%\", display: \"inline-block\" }}>\n                            or\n                        </Typography.Text>\n                        {renderFeatchUrlForm()}\n                    </div>\n                    <div className=\"right\">\n                        <Spin spinning={isLoad} style={{marginTop: \"20px\"}}>\n                            <TreeComp\n                                data={treeData as TInode[]}\n                                vfsService={treeVfss}\n                                onLaunchFileDetails={onCurrentFileContent}\n                            ></TreeComp>\n                        </Spin>\n                    </div>\n                    <div className=\"file-details\">\n                        <Details content={currentFileDetails}></Details>\n                    </div>\n                </Layout.Content>\n            </Layout>\n        </div>\n    );\n};\n\nexport default Page;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport Page from \"./page\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<Page />, document.getElementById(\"root\"));\n\nserviceWorker.unregister();\n"],"sourceRoot":""}